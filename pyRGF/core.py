#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 29 09:56:25 2014

@author: S. M. Popoff

v0.1 Python implementation from A. Goetschy's Matlab code
v0.2
"""

import matplotlib.pyplot as plt 

import time

from tqdm import tqdm
from .logger import get_logger

from math import pi
from .backends import ones
from .backends import zeros
# from .backends import round
# from .backends import floor_int
from .backends import to_float32
from .backends import arcsin
from .backends import sin
from .backends import cos
from .backends import exp
from .backends import sqrt
from .backends import arange
from .backends import rand_real
from .backends import is_shape
from .backends import real
from .backends import imag
from .backends import transpose
from .backends import eye
from .backends import diag
from .backends import inv
from .backends import mul
from .backends import matmul
from .backends import real_to_complex
from .backends import to_complex
from .backends import real
from .backends import imag
from .backends import conjugate

import numpy as np
from scipy.sparse import csr_matrix as sparse_matrix
from scipy.sparse.linalg import spsolve
from scipy import signal
import scipy.ndimage
import scipy.signal
# import .backends

import math
floor_int = math.trunc


DEVICE = 'cpu'

logger = get_logger(__name__)



class InputError(Exception):
    """Exception raised for errors in the input.

    Attributes:
        expr -- input expression in which the error occurred
        msg  -- explanation of the error
    """

    def __init__(self, msg):
        self.value = msg

    def __str__(self):
        return repr(self.value)
    
    
class EpsMap():
    
    def __init__(self):
        ## These default parameters are purely arbitrary, to be changed by the end user
        self.kdh = 1.                                           # sampling length
        self.kLx = 500                                         # length of the system
        self.kLx0_left = 10                                     # length of the empty wavegruide on the left
        self.kLx0_right = 10                                  # length of the empty wavegruide on the left
        self.kLy = 150                                         # width of the system
        self.eps_0 = 1.5**2                                         # Dielectric constant of the empty 
                                                                  # wavegide before the scattering region
        ## Only for random waveguide generated by GenerateRandomWG()     
        self.eps_wg = 1.5**2                                       # Dielectric constant of the empty wavegide
        self.e_scat = 0.0                                      # Amplitude of the disorder
        self.X = self.Y = None
        
        self.eps = None

    def update_parameters(self):
        # Number of points in the scattering medium in the x direction (propagation direction)
        self._Nx_scat = round(self.kLx/self.kdh - 1)
        self._Nx0_left = round(self.kLx0_left/self.kdh - 1)
        # Total number of points in the x direction, including the empty leads of size 
        # kLx0_left and kLx0_right
        self._Nx = round((self.kLx+self.kLx0_left+self.kLx0_right)/self.kdh - 1)
        
        self._Nx0_right = self._Nx-self._Nx0_left-self._Nx_scat
        # Number of y grid points   
        self._Ny = round((float(self.kLy)/self.kdh - 1))   
        
        self.X, self.Y = np.meshgrid(np.arange(self._Nx)/self.kdh, np.arange(self._Ny)/self.kdh)
        
        
    def get_param_dict(self, return_map = False):
        param_list = ['kdh', 
                      'kLx', 
                      'kLx0_left', 
                      'kLx0_right', 
                      'kLy', 
                      'eps_0', 
                      'eps_wg', 
                      'e_scat']

        additional_param_list = ['X', 'Y', 'eps'] if return_map else []
        param_list+=additional_param_list

        return_dict = {key: vars(self)[key] for key in param_list}
        
        return return_dict
        
        
    def generate_random_WG(self, kLcorr = None):
        '''
        kLcorr: correlation length of the disorder. 
                If kLcorr = None (default), kLcorr = kdh, all pixels are uncorrelated. 
                if kLcorr is set, it has to be larger than kdh, otherwise it is ignored
                and treated as None.
        '''
        
        self.update_parameters()
        
        
        
        
        # take larger arrays and crop after filtering to remove edge effects
        edge = 10
        
        
        if kLcorr and kLcorr > self.kdh:
            Nx2 = self._Nx_scat+2*edge
            Ny2 = self._Ny+2*edge
            e_d = (2*np.random.rand(Ny2,Nx2)-1*np.ones([Ny2,Nx2]))


            # Filter the random pattern to obtain the desired correlation length
            b, a = signal.butter(2, 1./kLcorr, 'low', fs = 2./self.kdh)
            e_d = signal.filtfilt(b, a, e_d)
            e_d = signal.filtfilt(b, a, e_d, axis = 0)
            e_d = e_d[edge:-edge,edge:-edge]
            # rescale the amplitude of disorder to fit the maximal amplitude set
            amp = np.max((np.abs(np.min(e_d)),np.abs(np.max(e_d))))
            e_d = 1./amp*self.e_scat*e_d


        else:
            e_d = self.e_scat*(2*rand_real([self._Ny,self._Nx_scat])-1*ones([self._Ny,self._Nx_scat]))
            
            

        self.eps = self.eps_0*ones([self._Ny,self._Nx]) 
        self.eps[:,self._Nx0_left:-self._Nx0_right] = self.eps_wg*ones([self._Ny,self._Nx_scat])+ e_d

    def display(self):
        plt.figure()
        plt.subplot(211)
        plt.title("Real part of eps")
        plt.imshow(real(self.eps), aspect='auto')
        plt.colorbar()
        plt.subplot(212)
        plt.title("Imaginary part of eps")
        plt.imshow(imag(self.eps), aspect='auto')
        plt.colorbar()
        plt.show()
        

class Parameters():
    
    def __init__(kdh, kLx):
        pass

class Solver():
    
    def __init__(self):
              
        ## Only for getting values in real units
        self.lbda = 0.8 # in um        
        
        self.eps_map = None

        
    def set_scale(self):
        """
        Give units to distance values, requires .lbda and all distance variables to be set by the user.
        Distances are normalized units in the calculation (i.e. kdh, kLx, etc...).
        It uses self.lbda to create varaibles .dh, .k, .Ly, .Lx, .Lx0_left, .Lx0_right.
        Distance values are in microns.
        """
        self.k = 2*pi/self.lbda
        self.dh = self.kdh/self.k
        self.Ly = self.kLy/self.k
        self.Lx = self.kLx/self.k
        self.Lx0_left = self.kLx0_left/self.k
        self.Lx0_right = self.kLx0_right/self.k
        
        
    def set_eps_map(self,eps_map):
        
        
#         if is_shape(eps_map, [self._Ny, self._Nx_scat]):
#             InputError( 'Dielectric constant map does not have the right size ([{0},{1}]) for {2}'.format(self._Ny, self._Nx_scat, self.kdh))
            #print("ERROR!: Dielectric constant map does not have the right size")
            #print "ERROR!: Dielectric constant map does not have the right size ([{0},{1}]) for {2}".format(self._Ny, self._Nx_scat, self.kdh)
            #print "ERROR!: Dielectric constant map does not have the right size ([%d,%d]) for %d" % (self._Ny, self._Nx_scat, self.kdh)
  
        self.eps_map = eps_map
        self._Nx = self.eps_map._Nx
        self._Ny = self.eps_map._Ny
#         self.eps_map = self.eps_0*ones([self._Ny,self._Nx])
#         Nx0_left = round((self.kLx0_left/self.kdh - 1))
#         self.eps_map[:,Nx0_left:Nx0_left+self._Nx_scat:,...] = eps_map
      
        self.generate_intermediate_parameters()
    
 
        
    def get_grid_size(self):
        self.generate_intermediate_parameters()
        return self.eps_map._Nx_scat, self.eps_map._Ny
        
    def generate_intermediate_parameters(self):
        
#         self._Nx_scat = round(self.kLx/self.kdh - 1)
#         self._Nx = round((self.kLx+self.kLx0_left+self.kLx0_right)/self.kdh - 1)            # Number of x grid points
#         self._Ny = round((float(self.kLy)/self.kdh - 1))            # Number of y grid points        
        
        self._ksqu=self.eps_map.kdh**2;

    
        # Number of propagative modes in the empty waveguide of dielectric constant eps_0
        self._N_modes = floor_int(((2/pi)*(self.eps_map.kLy/self.eps_map.kdh) \
                                   *math.asin(math.sqrt(self._ksqu*self.eps_map.eps_0)*0.5))-1e-5)
        # we add -1e-5 because is the number is exactly an integer, the last mode has a popagation constant equal to zero
            
        self._Ky_of_kysq = to_float32(2*(1-cos(arange(1,self._N_modes+1)*pi/(self._Ny+1))))
#         print(math.sqrt(self._ksqu*self.eps_0-self._Ky_of_kysq))
        self._phi =  sqrt(self._ksqu*self.eps_map.eps_0-self._Ky_of_kysq) \
                     * sqrt(1.-0.25*(self._ksqu*self.eps_map.eps_0-self._Ky_of_kysq))
        #self._phi = sqrt(self._ksqu-self._Ky_of_kysq)*sqrt(1-1/4*(self._ksqu-self._Ky_of_kysq))        
    
    def generate_mode_basis(self):
        #Transverse basis functions for discrete lattice
        logger.info(f"Generating mode basis for {self._N_modes} modes.")
        self._psi = zeros([self._N_modes,self._Ny])
        for jj in range(0,self._N_modes):
            self._psi[jj,...] = math.sqrt(2/(self._Ny+1)) \
                                * real_to_complex(sin((jj+1) *pi *arange(1,self._Ny+1)/(self._Ny+1)))
        logger.info(f"Mode basis generated.")
            
    def run(self):
        
        
        
        
        self.generate_intermediate_parameters()
        self.generate_mode_basis()        
        
        
        t0 = time.time()
        logger.info(f"Starting recursive Green's function iteration.")
        ## Green's function for first terminal.  This should give unity under
        # recursion on empty-lead slices.  Only keep propagating channels!
        self._kxdh=2*arcsin(0.5*sqrt(self._ksqu*self.eps_map.eps_0-self._Ky_of_kysq))
        self._gs = -to_complex(cos(self._kxdh) , sin(self._kxdh))
        #-exp(complex(0,1)*self._kxdh))
        self._G0 = matmul(diag(self._gs), self._psi)#[:,None,...]
        
#         print(self._G0)
#         raise

#         self._psi[...,0]@self._G0[...,0]
        self._G0 = matmul(transpose(self._psi), self._G0)
        
        Gn0 = self._G0
        G0n = self._G0
        Gnn = self._G0
        G00 = self._G0

        ## Recursive Green's function stepping



#         Ha = (- 4) * eye(self._Ny)
        Ha = (self._ksqu*self.eps_map.eps_wg- 4) * eye(self._Ny)
        for ii in range(0,self._Ny-1):
            real(Ha)[ii,ii+1] = 1
            real(Ha)[ii+1,ii] = 1
        
          
        ## Iteration scheme
        for ii in tqdm(range(0,self._Nx)):
            
#             H = Ha + diag(self._ksqu*self.eps_map[:,ii,...])
            H = Ha + diag(self._ksqu*(self.eps_map.eps[:,ii,...]-self.eps_map.eps_wg))
#             print(H.shape)
#             print(Gnn.shape)
            Gnn_new = inv(H - Gnn)
            Gn0_new = -1 * matmul(Gnn_new, Gn0)
            G0n_new = -1 * matmul(G0n, Gnn_new)
            G00_new = G00 - matmul(G0n, Gn0_new)
            Gnn = Gnn_new
            Gn0 = Gn0_new
            G0n = G0n_new
            G00 = G00_new
#             if (np.mod(ii,np.round(float(self._Nx)/100)) == 0):
#                 print('%d%%\r' % np.round(100.0*ii/float(self._Nx)))

                

        ## Last step
        Gnn_new = matmul(inv(eye(self._Ny) - matmul(self._G0, Gnn)),  self._G0)
        Gn0_new = -1 * matmul(Gnn_new, Gn0)
        G0n_new = -1 * matmul(G0n, Gnn_new)
        G00_new = G00 - matmul(G0n, Gn0_new)
        self._Gnn = Gnn_new
        self._Gn0 = Gn0_new
        self._G0n = G0n_new
        self._G00 = G00_new
        
        logger.info(f"RGF iteration finished in {time.time()-t0:.2f}s.")
        
        self.calculate_matrices()
        
    def calculate_TM(self, G_r, G_t):
        ''' 
        Get the reflection and transmission matrix from the Green's matrices
        Uses the Fisherâ€”Lee relation.
        '''
#         print(self._phi)
        phi_normv = matmul(diag(real_to_complex(sqrt(self._phi))), self._psi)
        self.phi_normv = phi_normv
        r = - eye(self._N_modes) + 2*complex(0,1) \
            * matmul(phi_normv, matmul(G_r,  conjugate(transpose(phi_normv))))
        t = 2*complex(0,1) \
            * matmul(phi_normv, matmul(G_t, conjugate(transpose(phi_normv))))
        return r, t
        
    def calculate_matrices(self):
        self.r1, self.t1 = self.calculate_TM(self._G00, self._Gn0)
        self.r2, self.t2 = self.calculate_TM(self._Gnn, self._G0n)
        #return r1, t1, r2, t2
    
    def get_matrices(self):
        return self.r1, self.t1, self.r2, self.t2
    
    def get_H_matrix(self):
        nxy = self._Nx*self._Ny
        ksq = self.eps_map.kdh**2
#         t1 = 1/ksq
#         t1sq = t1**2;


        # The first ny terms in epsnvec are now the dielectric functions on
        # the boundary, along the y direction.
        epsnvec = self.eps_map.eps.transpose().ravel()#reshape([nxy,-1])
        #reshape (epsn, nxy, 1);

        ## Set up, in Hterms, a matrix of row, col, value triplets for the PDE
        # matrix. 
        # Structure of Hterms :
        #  >> Hterms[0,...] and Hterms[1,...]: indices
        #  >> Hterms[2,...]: values
        # Start with the on-diagonal entries:
        idx = np.arange(nxy)
        Hterms = np.zeros((5*nxy-2*self._Nx-2*self._Ny), dtype= np.complex)
        Hindexes = np.zeros((5*nxy-2*self._Nx-2*self._Ny,2), dtype= np.int)
        Hterms[:nxy] = epsnvec * ksq - 4.
        Hindexes[:nxy,:] =  np.stack([idx, idx], axis = -1)
        
        Hidx = nxy#+1

        ## Vertical connections
        offd = np.ones(self._Ny-1, dtype = np.complex)
        for ii in range(self._Nx):
            idx = np.arange(self._Ny*ii,self._Ny*(ii+1))

            Hterms[Hidx:Hidx+self._Ny-1] = offd
            Hindexes[Hidx:Hidx+self._Ny-1,:] = np.stack([idx[:-1], idx[1:]], axis = -1)
            Hidx += self._Ny - 1

            Hterms[Hidx:Hidx+self._Ny-1] = offd
            Hindexes[Hidx:Hidx+self._Ny-1,:] = np.stack([idx[1:], idx[:-1]], axis = -1)
            Hidx += self._Ny - 1

        ## Horizontal connections
        offd = np.ones(self._Nx-1, dtype = np.complex)
        for jj in range(self._Ny):
            idx = self._Ny*np.arange(self._Nx) + jj
#           idx = ny*((1:nx)' - 1) + jj;

            Hterms[Hidx:Hidx+self._Nx-1] = offd
            Hindexes[Hidx:Hidx+self._Nx-1,:] = np.stack([idx[:-1], idx[1:]], axis = -1)
            Hidx = Hidx + self._Nx - 1

            Hterms[Hidx:Hidx+self._Nx-1] = offd
            Hindexes[Hidx:Hidx+self._Nx-1,:] = np.stack([idx[1:], idx[:-1]], axis = -1)
            Hidx = Hidx + self._Nx - 1

        ## Construct the PDE sparse matrix.
        H = sparse_matrix((Hterms, (Hindexes[:,0], Hindexes[:,1])))
        
        return H
    
    def get_internal_field(self, E_in_left = None, E_in_right = None):
        '''
        Assume only input from the right.
        '''
        
        if  E_in_right is None and  E_in_left is None:
            raise InputError('At least of input field (left or right) must be set.')
        elif E_in_right is None:
            logger.info('Excitation from the left side only.')
            E_in_right = np.zeros_like(E_in_left)
        elif E_in_left is None:
            logger.info('Excitation from the right side only.')
            E_in_left = np.zeros_like(E_in_right)    
            
        #odh2 = 1./self.dh**2
        speed_norm = diag(1./sqrt(self._phi))
        
        # Reflected field on the left
        E_out_left = self.r1 @ E_in_left + self.t2 @ E_in_right
        # Transmitted field on the right
        E_out_right = self.t1 @ E_in_left + self.r2 @  E_in_right
        psi_boundary_left = self._psi.transpose().conjugate() @ speed_norm @ (E_in_left + E_out_left)
        psi_boundary_right = self._psi.transpose().conjugate() @ speed_norm @ (E_in_right + E_out_right)
        
        
        self.speed_norm = speed_norm
        # Set the boundary conditions
        nxy = self._Nx*self._Ny
        rhs = zeros(nxy)
        rhs[:self._Ny] = - psi_boundary_left;
        rhs[-self._Ny:] = - psi_boundary_right;

        
        H = self.get_H_matrix()
        # Invert to find the internal fields.
        
        E_internal = spsolve(H, rhs)
        
        return E_internal.reshape(self._Nx,self._Ny).transpose()
#         internal_field = reshape (H \ rhs, ny, nx);


#         x = (1:nx)*dh;
#         y = (1:ny)*dh;
#         [x,y] = meshgrid(x,y);

        
   